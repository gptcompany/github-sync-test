#!/usr/bin/env python3
"""Shared GitHub sync logic for Speckit and GSD frameworks.

Provides unified functions for:
- Label management (auto-creation with standard colors)
- ProjectsV2 support (create, validate, add items via GraphQL)
- Milestone management
- Issue operations

Usage:
    from github_sync_core import (
        ensure_labels_exist,
        ensure_project_exists,
        add_issue_to_project,
        get_project_by_name,
    )
"""

from __future__ import annotations

import json
import subprocess
from dataclasses import dataclass

# =============================================================================
# Constants
# =============================================================================

# Standard labels with colors (hex without #)
STANDARD_LABELS = {
    "priority-p1": {"color": "b60205", "description": "High priority task"},
    "priority-p2": {"color": "fbca04", "description": "Medium priority task"},
    "priority-p3": {"color": "0e8a16", "description": "Low priority task"},
    "auto-generated": {"color": "c5def5", "description": "Auto-generated by SpecKit"},
    "parallelizable": {
        "color": "5319e7",
        "description": "Can be worked on in parallel",
    },
    "evolve": {"color": "bfdadc", "description": "Evolving/experimental task"},
    "todo": {"color": "d876e3", "description": "GSD todo item"},
    "gsd-phase": {"color": "0052cc", "description": "GSD phase"},
    "gsd-plan": {"color": "006b75", "description": "GSD plan"},
}

# Standard ProjectV2 columns for Kanban board (4 columns)
PROJECT_COLUMNS = [
    {"name": "Backlog", "color": "GRAY", "description": "Not started"},
    {"name": "In Progress", "color": "YELLOW", "description": "Being worked on"},
    {"name": "Review", "color": "PURPLE", "description": "In review"},
    {"name": "Done", "color": "GREEN", "description": "Completed"},
]


@dataclass
class ProjectInfo:
    """GitHub ProjectV2 information."""

    id: str
    number: int
    title: str
    url: str


# =============================================================================
# GitHub CLI Helpers
# =============================================================================


def run_gh_command(args: list[str], check: bool = True) -> tuple[int, str, str]:
    """Run a gh CLI command and return result."""
    try:
        result = subprocess.run(
            ["gh"] + args,
            capture_output=True,
            text=True,
            check=check,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.CalledProcessError as e:
        return e.returncode, e.stdout, e.stderr
    except FileNotFoundError:
        return 1, "", "gh CLI not found"


def run_graphql_query(
    query: str, variables: dict | None = None, silent: bool = False
) -> dict | None:
    """Execute a GraphQL query against GitHub API.

    Args:
        query: GraphQL query string
        variables: Query variables
        silent: If True, don't print errors (useful for exploratory queries)
    """
    cmd = ["api", "graphql", "-f", f"query={query}"]
    if variables:
        for key, value in variables.items():
            cmd.extend(["-f", f"{key}={value}"])

    code, stdout, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        if not silent:
            print(f"GraphQL error: {stderr}")
        # Try to parse anyway - partial data may be present
        try:
            result = json.loads(stdout) if stdout else None
            if result and result.get("data"):
                return result
        except json.JSONDecodeError:
            pass
        return None

    try:
        return json.loads(stdout)
    except json.JSONDecodeError:
        return None


def get_repo_info() -> tuple[str, str] | None:
    """Get current repository owner and name from git."""
    code, stdout, _ = run_gh_command(
        ["repo", "view", "--json", "owner,name", "-q", ".owner.login,.name"],
        check=False,
    )
    if code != 0 or not stdout:
        return None

    parts = stdout.strip().split("\n")
    if len(parts) >= 2:
        return parts[0], parts[1]
    return None


def get_repo_node_id() -> str | None:
    """Get the repository's GraphQL node ID."""
    code, stdout, _ = run_gh_command(
        ["repo", "view", "--json", "id", "-q", ".id"],
        check=False,
    )
    return stdout.strip() if code == 0 and stdout else None


# =============================================================================
# Label Management
# =============================================================================


def get_existing_labels() -> set[str]:
    """Get existing labels in the repository."""
    code, stdout, _ = run_gh_command(
        ["label", "list", "--json", "name", "-q", ".[].name"],
        check=False,
    )
    if code != 0:
        return set()
    return set(stdout.strip().split("\n")) if stdout.strip() else set()


def ensure_labels_exist(labels: list[str], dry_run: bool = False) -> list[str]:
    """Ensure required labels exist, creating any that are missing.

    Returns list of labels that were created.
    """
    existing = get_existing_labels()
    created = []

    for label in labels:
        if label in existing:
            continue

        # Check if it's a standard label with defined color
        if label in STANDARD_LABELS:
            label_config = STANDARD_LABELS[label]
            color = label_config["color"]
            description = label_config["description"]
        elif label.startswith("spec-"):
            # Spec labels get a standard color
            color = "1d76db"
            description = f"Related to {label}"
        elif label.startswith("phase-"):
            # Phase labels
            color = "0052cc"
            description = f"GSD {label}"
        elif label.startswith("milestone-"):
            # Milestone labels
            color = "5319e7"
            description = f"GSD {label}"
        else:
            # Default for unknown labels
            color = "ededed"
            description = ""

        if dry_run:
            print(f"[DRY RUN] Would create label: {label}")
            created.append(label)
            continue

        cmd = ["label", "create", label, "--color", color]
        if description:
            cmd.extend(["--description", description])

        code, _, stderr = run_gh_command(cmd, check=False)
        if code == 0:
            print(f"Created label: {label}")
            created.append(label)
        else:
            # Label might already exist (race condition) or other error
            if "already exists" not in stderr.lower():
                print(f"Warning: Could not create label {label}: {stderr}")

    return created


# =============================================================================
# ProjectsV2 Management (GraphQL)
# =============================================================================


def get_project_by_name(owner: str, project_name: str) -> ProjectInfo | None:
    """Get a ProjectV2 by name using GraphQL.

    Args:
        owner: Repository owner (user or organization)
        project_name: Project title to search for

    Returns:
        ProjectInfo if found, None otherwise
    """
    # Query both user and organization projects
    query = """
    query($owner: String!, $projectName: String!) {
      user(login: $owner) {
        projectsV2(first: 100, query: $projectName) {
          nodes {
            id
            number
            title
            url
          }
        }
      }
      organization(login: $owner) {
        projectsV2(first: 100, query: $projectName) {
          nodes {
            id
            number
            title
            url
          }
        }
      }
    }
    """

    # Use silent=True because one of user/org will always fail
    result = run_graphql_query(
        query, {"owner": owner, "projectName": project_name}, silent=True
    )
    if not result:
        return None

    # Check user projects first, then organization
    for source in ["user", "organization"]:
        data = result.get("data", {}).get(source)
        if data and data.get("projectsV2", {}).get("nodes"):
            for project in data["projectsV2"]["nodes"]:
                if project["title"] == project_name:
                    return ProjectInfo(
                        id=project["id"],
                        number=project["number"],
                        title=project["title"],
                        url=project["url"],
                    )

    return None


def create_project(
    owner: str, project_name: str, dry_run: bool = False
) -> ProjectInfo | None:
    """Create a new ProjectV2 using GraphQL.

    Args:
        owner: Repository owner
        project_name: Title for the new project
        dry_run: If True, don't actually create

    Returns:
        ProjectInfo for the created project, None on failure
    """
    if dry_run:
        print(f"[DRY RUN] Would create project: {project_name}")
        return None

    # First, get the owner's node ID
    query = """
    query($owner: String!) {
      user(login: $owner) {
        id
      }
      organization(login: $owner) {
        id
      }
    }
    """

    # Use silent=True because one of user/org will always fail
    result = run_graphql_query(query, {"owner": owner}, silent=True)
    if not result:
        return None

    owner_id = None
    for source in ["user", "organization"]:
        data = result.get("data", {}).get(source)
        if data and data.get("id"):
            owner_id = data["id"]
            break

    if not owner_id:
        print(f"Could not find owner ID for {owner}")
        return None

    # Create the project
    mutation = """
    mutation($ownerId: ID!, $title: String!) {
      createProjectV2(input: {ownerId: $ownerId, title: $title}) {
        projectV2 {
          id
          number
          title
          url
        }
      }
    }
    """

    result = run_graphql_query(mutation, {"ownerId": owner_id, "title": project_name})
    if not result:
        return None

    project_data = result.get("data", {}).get("createProjectV2", {}).get("projectV2")
    if project_data:
        print(f"Created project: {project_name}")
        project_info = ProjectInfo(
            id=project_data["id"],
            number=project_data["number"],
            title=project_data["title"],
            url=project_data["url"],
        )
        # Configure 4-column Kanban board
        _configure_project_columns(project_info.id)
        return project_info

    return None


def _configure_project_columns(project_id: str) -> bool:
    """Configure project Status field with 4-column Kanban layout.

    Args:
        project_id: GraphQL node ID of the project

    Returns:
        True if successful
    """
    # Get the Status field ID
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          field(name: "Status") {
            ... on ProjectV2SingleSelectField {
              id
            }
          }
        }
      }
    }
    """
    result = run_graphql_query(query, {"projectId": project_id}, silent=True)
    if not result:
        return False

    field_data = result.get("data", {}).get("node", {}).get("field")
    if not field_data or not field_data.get("id"):
        return False

    field_id = field_data["id"]

    # Build options from PROJECT_COLUMNS
    options_str = ", ".join(
        f'{{ name: "{col["name"]}", color: {col["color"]}, description: "{col["description"]}" }}'
        for col in PROJECT_COLUMNS
    )

    mutation = f"""
    mutation {{
      updateProjectV2Field(input: {{
        fieldId: "{field_id}"
        singleSelectOptions: [{options_str}]
      }}) {{
        projectV2Field {{
          ... on ProjectV2SingleSelectField {{
            options {{ name }}
          }}
        }}
      }}
    }}
    """

    result = run_graphql_query(mutation, silent=True)
    if result and result.get("data"):
        print("  Configured 4-column Kanban board")
        return True
    return False


def ensure_project_exists(
    owner: str, project_name: str, dry_run: bool = False
) -> ProjectInfo | None:
    """Ensure a ProjectV2 exists, creating if necessary.

    Args:
        owner: Repository owner
        project_name: Project title
        dry_run: If True, don't create

    Returns:
        ProjectInfo for existing or newly created project
    """
    existing = get_project_by_name(owner, project_name)
    if existing:
        print(f"Project exists: {existing.title} (#{existing.number})")
        return existing

    return create_project(owner, project_name, dry_run)


def add_issue_to_project(
    project_id: str, issue_node_id: str, dry_run: bool = False
) -> str | None:
    """Add an issue to a ProjectV2 using GraphQL.

    Args:
        project_id: GraphQL node ID of the project
        issue_node_id: GraphQL node ID of the issue
        dry_run: If True, don't actually add

    Returns:
        Item ID if successful, None otherwise
    """
    if dry_run:
        print("[DRY RUN] Would add issue to project")
        return None

    mutation = """
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
        item {
          id
        }
      }
    }
    """

    result = run_graphql_query(
        mutation, {"projectId": project_id, "contentId": issue_node_id}
    )
    if not result:
        return None

    item_data = result.get("data", {}).get("addProjectV2ItemById", {}).get("item")
    return item_data.get("id") if item_data else None


def get_issue_node_id(issue_number: int) -> str | None:
    """Get the GraphQL node ID for an issue by number."""
    code, stdout, _ = run_gh_command(
        ["issue", "view", str(issue_number), "--json", "id", "-q", ".id"],
        check=False,
    )
    return stdout.strip() if code == 0 and stdout else None


# =============================================================================
# Milestone Management
# =============================================================================


def get_existing_milestones() -> dict[str, int]:
    """Get existing milestones and their numbers."""
    # Use proper jq to get interleaved title,number pairs
    code, stdout, _ = run_gh_command(
        ["api", "repos/{owner}/{repo}/milestones", "-q", ".[] | .title, .number"],
        check=False,
    )
    if code != 0:
        return {}

    milestones = {}
    lines = stdout.strip().split("\n")
    for i in range(0, len(lines) - 1, 2):
        if lines[i] and lines[i + 1]:
            try:
                milestones[lines[i]] = int(lines[i + 1])
            except ValueError:
                # If parsing fails, skip this milestone
                continue
    return milestones


def create_milestone(
    title: str, description: str = "", dry_run: bool = False
) -> int | None:
    """Create a GitHub milestone.

    Args:
        title: Milestone title
        description: Optional description
        dry_run: If True, don't actually create

    Returns:
        Milestone number if successful, None otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would create milestone: {title}")
        return None

    cmd = [
        "api",
        "repos/{owner}/{repo}/milestones",
        "--method",
        "POST",
        "-f",
        f"title={title}",
        "-f",
        "state=open",
        "-q",
        ".number",
    ]
    if description:
        cmd.extend(["-f", f"description={description}"])

    code, stdout, _ = run_gh_command(cmd, check=False)
    return int(stdout.strip()) if code == 0 and stdout else None


def ensure_milestone_exists(
    title: str, description: str = "", dry_run: bool = False
) -> int | None:
    """Ensure a milestone exists, creating if necessary.

    Returns:
        Milestone number
    """
    existing = get_existing_milestones()
    if title in existing:
        print(f"Milestone exists: {title} (#{existing[title]})")
        return existing[title]

    milestone_num = create_milestone(title, description, dry_run)
    if milestone_num:
        print(f"Created milestone: {title} (#{milestone_num})")
    return milestone_num


# =============================================================================
# Issue Operations
# =============================================================================


def create_issue(
    title: str,
    body: str,
    labels: list[str] | None = None,
    milestone_num: int | None = None,
    project_id: str | None = None,
    dry_run: bool = False,
) -> int | None:
    """Create a GitHub issue and optionally link to project.

    Args:
        title: Issue title
        body: Issue body (markdown)
        labels: List of label names
        milestone_num: Milestone number to assign
        project_id: ProjectV2 node ID to add issue to
        dry_run: If True, don't actually create

    Returns:
        Issue number if successful, None otherwise
    """
    if dry_run:
        print(f"[DRY RUN] Would create issue: {title}")
        return None

    cmd = ["issue", "create", "--title", title, "--body", body]
    for label in labels or []:
        cmd.extend(["--label", label])
    if milestone_num:
        cmd.extend(["--milestone", str(milestone_num)])

    code, stdout, stderr = run_gh_command(cmd, check=False)
    if code != 0:
        print(f"Failed to create issue: {stderr}")
        return None

    # Extract issue number from URL
    import re

    match = re.search(r"/issues/(\d+)", stdout)
    if not match:
        return None

    issue_num = int(match.group(1))

    # Add to project if specified
    if project_id:
        issue_node_id = get_issue_node_id(issue_num)
        if issue_node_id:
            add_issue_to_project(project_id, issue_node_id, dry_run)

    return issue_num


def close_issue(issue_number: int, dry_run: bool = False) -> bool:
    """Close a GitHub issue.

    Returns:
        True if successful
    """
    if dry_run:
        print(f"[DRY RUN] Would close issue #{issue_number}")
        return True

    code, _, _ = run_gh_command(["issue", "close", str(issue_number)], check=False)
    return code == 0


def get_existing_issues(label_filter: str | None = None) -> dict[str, dict]:
    """Get existing issues, optionally filtered by label.

    Returns dict mapping task/item ID to issue info.
    """
    import re

    query = "is:issue"
    if label_filter:
        query += f" label:{label_filter}"

    code, stdout, _ = run_gh_command(
        [
            "issue",
            "list",
            "--search",
            query,
            "--state",
            "all",
            "--limit",
            "500",
            "--json",
            "number,title,state,id",
        ],
        check=False,
    )
    if code != 0:
        return {}

    issues = {}
    try:
        data = json.loads(stdout) if stdout else []
        for issue in data:
            # Match task ID pattern (T\d+) or plan/phase pattern
            match = re.search(r"(T\d+|Phase-\d+|Plan-[\w-]+)", issue.get("title", ""))
            if match:
                issues[match.group(1)] = {
                    "number": issue["number"],
                    "state": issue["state"],
                    "title": issue["title"],
                    "node_id": issue.get("id"),
                }
    except json.JSONDecodeError:
        pass
    return issues
